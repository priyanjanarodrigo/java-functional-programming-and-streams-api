package com.myorg.streamsAPI.IntStreams;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class IntStreamsDemo {

    /**
     * We have 3 distinct parts of streams
     * 1. Create
     * 2. Process
     * 3. Consume
     *
     * Example:
     *      IntStream.of(numbers) <------------------- (1) Create
     *          .distinct() <--:
     *          .sorted()      :---------------------- (2) Process
     *          .limit(3)   <--:
     *          .forEach(System.out::println); <------ (3) Consume
     */

    public static void execute(String methodName, Runnable runnable) {
        System.out.println(methodName);
        runnable.run();
        System.out.println();
    }

    public static void intStreamCreation() {
        IntStream.empty(); // Creates an empty IntStream

        IntStream.of(1, 3, 4, 6, 7).forEach(System.out::println);

        System.out.println();

        // Will create a IntStream from start to end-1 (In this case 0 to 9). 10 int elements are generated here
        IntStream.range(0, 10).forEach(System.out::println);

        System.out.println();

        // Will create a IntStream from start to exact end (In this case 0 to 10). 11 int elements are generated here
        IntStream.rangeClosed(0, 10).forEach(System.out::println);

        System.out.println();

        /**
         * IntStream generate(IntSupplier s) returns an infinite sequential unordered stream where each element is
         * generated by the provided IntSupplier(a supplier of int-valued results). This is suitable for generating
         * constant streams, streams of random elements
         * */
        // Using IntStream.generate() method to generate 7 random Integer values
        IntStream intStream = IntStream.generate(() -> (int) (Math.random() * 10000));

        // Displaying the randomly generated values
        intStream.limit(7).forEach(System.out::println);
    }

    public static void intStreamProcessing(int[] values) {
        IntStream.of(values).distinct();                        // distinct

        IntStream.of(values).sorted();                          // sorted

        IntStream.of(values).limit(5);                          // get first 5/ limit to 5

        IntStream.of(values).skip(2);                           // skip first 2

        IntStream.of(values).filter(number -> number % 2 == 0); // filter even numbers only

        IntStream.of(values).map(number -> number * 2);         // double each number value

        IntStream.of(values).boxed();                           // Covert each int number to Integer wrapper type

        IntStream.of(values).asDoubleStream();                  // Converts the stream into a DoubleStream

        IntStream.of(values).asLongStream();                    // Converts the stream into a LongStream

        IntStream.concat(IntStream.of(values), IntStream.of(3, 4, 5)); // Concatenates two IntStreams

        int total = IntStream.of(1, 2, 3, 4, 5)
                .reduce((i1, i2) -> i1 + i2).getAsInt();        // reduce operation. Here, gets total of all

        System.out.println(total);
    }

    public static void intStreamConsuming(int[] numbers) {
        IntStream.of(numbers).average();
        IntStream.of(numbers).count();
        IntStream.of(numbers).sum();
        IntStream.of(numbers).min();
        IntStream.of(numbers).max();

        IntStream.range(1, 100).forEach(System.out::println);        //prints 1 to 99
        IntStream.rangeClosed(1, 100).forEach(System.out::println);  //prints 1 to 100
        List<Integer> list = IntStream.range(1, 100).boxed()
                .collect(Collectors.toList()); // collected into an Integer wrapper type list

        IntStream.of(numbers).anyMatch(num -> num % 2 == 1); // is any number odd
        IntStream.of(numbers).allMatch(num -> num % 2 == 1); // are all numbers odd
    }

    public static void aggregateOperations(int[] values) {
        /** Step-by-step approach ------------------------------------------------------------------------------------*/
        OptionalInt minimumValue = IntStream.of(values).min();
        int minimumValueInInt = minimumValue.getAsInt();
        System.out.println(minimumValueInInt);

        OptionalInt maximumValue = IntStream.of(values).max();
        int maximumValueInInt = maximumValue.getAsInt();
        System.out.println(maximumValueInInt);

        int sumOfValues = IntStream.of(values).sum();
        System.out.println(sumOfValues);

        long countOfValues = IntStream.of(values).count();
        System.out.println(countOfValues);

        OptionalDouble averageOfValues = IntStream.of(values).average();
        double averageOfValuesInDouble = averageOfValues.getAsDouble();
        System.out.println(averageOfValuesInDouble);

        /** Shorthand approach ---------------------------------------------------------------------------------------*/
        int minValue = IntStream.of(values).min().getAsInt();
        System.out.println(minValue);

        int maxValue = IntStream.of(values).max().getAsInt();
        System.out.println(maxValue);

        double average = IntStream.of(values).average().getAsDouble();
        System.out.println(average);

        long count = IntStream.of(values).count();
        System.out.println(count);

        int sum = IntStream.of(values).sum();
        System.out.println(sum);
    }

    public static void singleCallForAllStatistics(int[] numbers) {
        IntSummaryStatistics intSummaryStatistics = IntStream.of(numbers).summaryStatistics();

        int min = intSummaryStatistics.getMin();
        System.out.println(min);

        int max = intSummaryStatistics.getMax();
        System.out.println(max);

        double average = intSummaryStatistics.getAverage();
        System.out.println(average);

        long count = intSummaryStatistics.getCount();
        System.out.println(count);

        long sum = intSummaryStatistics.getSum();
        System.out.println(sum);
    }

    public static void find3DistinctSmallestNumbers(int[] numbers) {

        // Imperative approach -----------------------------------------------------------------------------------------
        int[] clonedArray = Arrays.copyOf(numbers, numbers.length);// Cloning the numbers array into a new one
        Arrays.sort(clonedArray); // Sorting the array
        LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();

        for (int number : clonedArray) {
            if (linkedHashSet.size() == 3) {
                break;
            }
            linkedHashSet.add(number);
        }

        linkedHashSet.forEach(System.out::println);

        System.out.println();

        // Declarative approach ----------------------------------------------------------------------------------------

        // Here the original array is not mutated and internally creates a copy
        IntStream.of(numbers)
                .distinct()
                .sorted()
                .limit(3)
                .forEach(System.out::println);

        IntStream.of(numbers).distinct().sorted().limit(3)
                .sum(); // average(), count(), min(), max() any statistical methods are possible to be applied
    }

    public static void main(String[] args) {

        int[] values = {1, 4, 6, 3, 5, 7, 2, 0, 9, 8};
        execute("intStreamCreation", IntStreamsDemo::intStreamCreation);
        execute("intStreamProcessing", () -> IntStreamsDemo.intStreamProcessing(values));
        execute("intStreamConsuming", () -> IntStreamsDemo.intStreamConsuming(values));
        execute("aggregateOperations", () -> IntStreamsDemo.aggregateOperations(values));
        execute("singleCallForAllStatistics", () -> IntStreamsDemo.singleCallForAllStatistics(values));

        int[] numbers = {1, 1, 2, 2, 2, 7, 5, 0, 4, 3};
        execute("find3DistinctSmallestNumbers", () -> IntStreamsDemo.find3DistinctSmallestNumbers(numbers));
    }
}
;